
### 介绍
快速排序可能是应用最广泛的算法，实现简单，特点有二：其一，它是原地排序（只需要一个很小的辅助栈）。其二，将长度为 N 的数组排序所需的时间和 NlgN 成正比。缺点是非常脆弱，实现时要非常小心，许多错误会让性能只有平方级别。

快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。两个子数组都有序时整个数组就有序了。两个子数组怎么排序？当然是递归调用上述操作咯～

那么重点来了，快速排序的关键就在如何切分（partition）数组了。

大致过程看这张图：  
> ![](https://pikachu666.oss-cn-hongkong.aliyuncs.com/github/blog/algorithm_4/quicksort-overview.png)  
> 快速排序示意图

``` java
public class Quick {

    public static void sort(Comparable[] a) {
        StdRandom.shuffle(a);    //消除对输入的依赖（打乱数组）
        sort(a, 0, a.length - 1);
    }

    private static void sort(Comparable[] a, int lo, int hi) {
        if (hi <= lo)
	        return;
        int j = partition(a, lo, hi);   //切分（见下文）
        sort(a, lo, j-1);     //将左半部分 a[lo .. j-1] 排序
        sort(a, j+1, hi);     //将右半部分 a[j+1 .. hi] 排序
    }
}
```

快速排序递归地将子数组 a[lo .. hi] 排序，先用 partition() 方法将 a[j] 放到一个合适位置，然后再用递归调用将其他位置的元素排序。  

> ![](https://pikachu666.oss-cn-hongkong.aliyuncs.com/github/blog/algorithm_4/quicksort.png)    

上述过程使得数组满足三个条件：
 - 对于某个 j，a[j] 已经排定
 - a[lo] 到 a[j-1] 中的所有元素都不大于 a[j]
 - a[j+1] 到 a[hi] 中的所有元素都不小于 a[j]

递归的调用切分就完成了排序，因为每次切分总能排定一个元素。

如果左子数组和右子数组都是有序的，那么由左子数组（有序且没有任何元素大于切分元素）、切分元素和右子数组（有序且没有任何元素小于切分元素）组成的结果数组也一定是有序的。

### 切分
一般策略是先随意地取 a[lo] 作为切分元素，即那个将会被排定的元素，然后我们从数组的左侧向又扫描直到找到一个大于等于它的元素，再从数组的右端开始向左侧扫描直到一个小于等于它的元素。这两个元素显然是没有排定的，因此交换它们的位置。如此继续，就可以保证左指针 i 的左侧元素都不大于切分元素，右指针 j 的右侧元素都不小于切分元素。当两个指针相遇时，只需要将切分元素 a[lo] 和左子数组最右侧的元素 (a[j]) 交换然后返回 j 即可。  

> ![](https://pikachu666.oss-cn-hongkong.aliyuncs.com/github/blog/algorithm_4/partitioning-overview.png)    
> 切分示意图

``` java
private static int partition(Comparable[] a, int lo, int hi) {
    int i = lo;         //左指针
    int j = hi + 1;     //右指针
    Comparable v = a[lo];   //切分元素
    while (true) {

        // 从左边开始找到大于切分元素的元素
        while (less(a[++i], v))
            if (i == hi) break;

        // 从右边开始找到小于切分元素的元素
        while (less(v, a[--j]))
            if (j == lo) break;      

        // 检查指针是否交叉
        if (i >= j) break;

        exch(a, i, j);
    }

    // 将切分点放入正确的位置
    exch(a, lo, j);

    // 现在, a[lo .. j-1] <= a[j] <= a[j+1 .. hi] 条件达成
    return j;
}
```

这段代码按照 a[lo] 的值 v 进行切分。当指针 i 和 j 相遇时主循环退出。 在循环中，a[i] 小于 v 时我们增大 i，a[j] 大于 v 时我们减小 j，然后交换 a[i] 和 a[j] 来保证 i 左侧的元素都不大于 v，j 右侧的元素都不小于 v。当指针相遇时交换 a[lo] 和 a[j]，切分结束（这样切分值就留在 a[j] 中了）。  

> ![](https://pikachu666.oss-cn-hongkong.aliyuncs.com/github/blog/algorithm_4/partitioning.png)   
> 切分轨迹（每次交换前后的数组内容）

### 注意事项
 * **原地切分**  
 使用辅助数组可以容易的实现切分，但将切分后的数组复制回去的开销也许会得不偿失。如果不小心将数组创建在递归的切分方法中，还会大大降低排序的速度。  
 * **别越界**  
 如果切分元素是数组中最小或最大的那个元素，就要小心别让扫描指针跑出数组的边界。  
 * **保持随机性**  
 保持输入随机，这对于预测算法的运行时间很重要。另一种方法是在 partition() 中随机选择一个切分元素。  
 * **终止循环**  
 注意正确终止循环的条件。  
 * **处理切分元素值有重复的情况**
 * **避免无限递归**


### 算法改进
#### 切换到插入排序
对于小数组，快速排序比插入排序慢，因为递归，快速排序的 sort() 方法在小数组中也会调用自己。因此，在排序小数组时应该切换到插入排序。

到底多小的数组才切换到插入排序呢，这和系统相关，但是 5 ～ 15 之间的任意值在大多数情况下都能令人满意。

#### 三取样切分

使用子数组的一小部分元素的中位数来切分数组。这样做得到的切分更好，但代价是需要计算中位数。

将取样大小设为 3 并用大小剧中的元素切分的效果最好。

还可以将取样元素放到数组末尾作为 “哨兵” 来去掉 partition() 中的数组边界测试。

#### 熵最优的排序

这种方法的出现是为了解决有大量重复元素的数组，这种方法可以将有大量重复元素的数组排序的性能提高到线性级别。


### 结论
 * **将长度为 N 的无重复数组排序，快速排序平均需要 ～2NlnN 次比较（以及 1/6 的交换）。**
 * **快速排序最多需要约 N^2/2 次比较，但随机打乱数组能够预防这种情况。**
 * **不存在任何基于比较的排序算法能够保证在 NH-N 次比较之内将 N 个元素排序，其中 H 为由主键值出现频率定义的香农信息量**
 * **对于大小为 N 的数组，三向切分的快速排序需要 ～(2ln2)NH 次比较。其中 H 为由主键值出现频率定义的香农信息量**


### 说明

本文内容是对『算法』第四版 的摘要总结！  
文章所用图片来自 [『算法』第四版 英文原版](http://algs4.cs.princeton.edu/home/) 。
