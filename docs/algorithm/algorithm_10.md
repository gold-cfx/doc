
### 散列表

用一个数组来实现无序的符号表，将键作为数组的索引而数组中键 i 处存储的就是它对应的值。这样就可以快速访问任意键的值。散列表就是这种简易方法的扩展并能够处理更加复杂的类型的键。需要用算术操作将键转化为数组中索引来访问数组中的键值对。

散列表的查找算法分为两步：
 - 用散列函数将被查找的键转化为数组的一个索引，不同的键转化后的索引值可能相同。
 - 处理碰撞冲突（不同键的索引值相同的情况），常见的方法有：拉链法和线性探测法。


> ![](https://pikachu666.oss-cn-hongkong.aliyuncs.com/github/blog/algorithm10/hashing-crux.png)
> 散列表的核心问题



散列表是算法在时间和空间上作出权衡的经典例子。
> 如果没有内存限制，可以直接将键作为数组的索引，那么所有查找操作只需要访问内存一次即可完成。
> 如果没有时间限制，可以使用无序数组并进行顺序查找，这样只需要很少的内存。
> 散列表在这之间找到了平衡。



### 散列函数

散列函数的作用是将 键 转化为 数组的索引。

如果有一个能够保存 M 个键值对的数组，那么就需要一个能够将任意键转化为该数组范围内的索引（[0,M-1]范围内的整数）的散列函数。

散列函数应该易于计算并且能够均匀分布所有的键。

### 常见的计算准则

#### 正整数

整数散列最常用方法是除留余数法。选择大小为素数 M 的数组，对于任意正整数 k，计算 k 除以 M 的余数。

如果 M 不是素数，可能无法利用键中包含的所有信息，导致无法均匀地 散列 散列值。

![](https://pikachu666.oss-cn-hongkong.aliyuncs.com/github/blog/algorithm10/modular-hashing.png)

#### 浮点数

当键是 0 到 1 之间的实数时，可以将它乘以 M 并四舍五入得到一个 0 至 M-1 之间的索引值。

这种方法很容易理解，但是也有缺陷，这种情况下键的高位起的作用更大，最低位对散列的结果没有影响。

解决的办法是将键表示为二进制数然后再使用除留余数法。
> java 就是这么做的



#### 字符串

除留余数法也可以处理较长的键，比如字符串，只需将它们当作大整数即可。

``` java
int hash = 0;
for (int i = 0; i < s.length(); i++)
    hash = (R * hash + s.charAt(i)) % M;
```


#### 组合键

如果键的类型含有多个变量，可以和 String 类型一样将它们混合起来。或是分别计算，最后再混合。



### 基于拉链法的散列表

将数组中每个元素指向一条链表，链表中每个结点都存储了散列值为该元素的索引的键值对。这种方法就是拉链法，因为发生冲突的元素都被存储在链表中。

这个方法的基本思想就是选择足够大的数组长度，让所有链表都尽可能短以保证高效的查找。

查找分两步：
 - 根据散列值查到对应的链表
 - 沿着链表查找对应的键

![](https://pikachu666.oss-cn-hongkong.aliyuncs.com/github/blog/algorithm10/separate-chaining.png)

**在一张含有 M 条链接和 N 个键的散列表中，（键能均匀的散列的前提下）任意一条链表中的键的数量均在 N/M 的常数因子范围内的概率无限趋向于 1。**


### 基于线性探测法的散列表

用大小为 M 的数组保存 N 个键值对，其中 M > N 。需要依靠数组中的空位解决碰撞冲突。基于这种策略的所有方法被统称为开放地址散列表。

开放地址散列表中最简单的方法叫做 线性探测法：**当碰撞发生时（当一个键的散列值已经被另一个不同的键占用），直接检查散列表中的下一个位置（将索引值加 1）。**  
**这样的线性探测可能会产生三种结果：**  
 - 命中，该位置的键和被查找的键相同
 - 未命中，键为空（该位置没有键）
 - 继续查找，该位置的键和被查找的键不同


![](https://pikachu666.oss-cn-hongkong.aliyuncs.com/github/blog/algorithm10/linear-probing.png)


#### 删除操作
在删除时无法直接将键所在的位置设为 null ，因为这会使得在此位置之后的元素无法被查找。因此，需要将簇中被删除键的右侧的所有键重新插入散列表。


#### 箭簇

线性探测的平均成本取决于元素在插入数组后聚集成的一组连续的条目，也叫做 箭簇。

![](https://pikachu666.oss-cn-hongkong.aliyuncs.com/github/blog/algorithm10/d49bcae0-4c37-4141-9a67-c073df0e54d8.png)

显然，短小的箭簇才能保证较高的效率。



### 各种符号表实现的渐进性能的总结

![](https://pikachu666.oss-cn-hongkong.aliyuncs.com/github/blog/algorithm10/e76eaa6e-c56d-4cbc-a205-53527bbc5bfe.png)


### 说明
本文内容是对『算法』第四版 的摘要总结！  
文章所用图片部分来自 [『算法』第四版 英文原版](http://algs4.cs.princeton.edu/home/) ，部分来自 **『算法』第四版 中文译版**