# 通用命令

## keys 

`keys <pattern>`

根据模式返回指定的 key

例如

```
127.0.0.1:6379> keys *
1) "hash-key"
2) "hello"
127.0.0.1:6379> keys ha*
1) "hash-key"
127.0.0.1:6379> keys *lo
1) "hello"
127.0.0.1:6379> 
```

## dbsize

计算 key 的总数

```
127.0.0.1:6379> dbsize
(integer) 2
127.0.0.1:6379> 
```

## exists

`exists <key>`

判断 key 是否存在

```
127.0.0.1:6379> exists hello
(integer) 1
127.0.0.1:6379> exists he
(integer) 0
```

## del

`del <key> [key]...`

删除指定 key

## expire

`expire <key> <seconds>`

设置 key 的过期时间

## ttl

`ttl <key>`

查看 key 剩余的过期时间

```
127.0.0.1:6379> set hello world
OK
127.0.0.1:6379> expire hello 10
(integer) 1
127.0.0.1:6379> ttl hello
(integer) 5
127.0.0.1:6379> ttl hello
(integer) 2
127.0.0.1:6379> ttl hello
(integer) -2
127.0.0.1:6379> get hello
(nil)
```

`ttl <key>` 返回 `-2` 表示 key 已经过期，被删除了。返回 `-1` 表示数据依然存在

## persist

`persist <key>`

去掉 key 的过期时间

```
127.0.0.1:6379> set hello world
OK
127.0.0.1:6379> expire hello 20
(integer) 1
127.0.0.1:6379> ttl hello
(integer) 15
127.0.0.1:6379> persist hello
(integer) 1
127.0.0.1:6379> ttl hello
(integer) -1
127.0.0.1:6379> get hello
"world"
```

## type

`type <key>`

检查 key 的数据类型

```
127.0.0.1:6379> type he
string
127.0.0.1:6379> type hash-key
hash
127.0.0.1:6379> type asd  # key 不存在
none
127.0.0.1:6379> 
```

## 时间复杂度

| 命令 | 复杂度
|:-----------
| keys | O(n)
| dbsize | O(1)
| del | O(1)
| exists | O(1)
| expire | O(1)
| type | O(1)



# Redis 提供的 5 种数据结构

| 结构类型 | 结构存储的值 | 结构的读写能力 |
|:--------------------------------------
| STRING | 可以是字符串、整数或者浮点数 | 对整个字符串或者字符串的其中一部分执行操作：对整数和浮点数执行自增（increment）或者自减（decrement）操作
| LIST | 一个链表，链表上的每个节点都包含了一个字符串 | 从链表的两端推入或者弹出元素：根据偏移量对链表进行修剪（trim）：读取单个或者多个元素：根据值查找或者移出元素
| SET | 包含字符串的无序收集器（unordered collection），并且被包含的每个字符串都是独一无二、各不相同的 | 添加、获取、移除单个元素：检查一个元素是否存在于集合中：计算交集、并集、差集：从集合中随机获取元素
| HASH | 包含键值对的无序散列表 | 添加、获取、移除单个键值对：获取所有键值对
| ZSET（有序集合） | 字符串成员（member）与浮点数分值（score）之间的有序映射，元素的排列顺序由分值的大小决定 | 添加、获取、移除单个元素：根据分值范围（range）或者成员来获取元素

## 字符串 string

| 命令 | 行为
|:----------
| `get <key>` | 获取存储在给定键中的值
| `set <key> <val>` | 设置存储在给定键中的值
| `setnx <key> <val>` | key 不存在才设置值
| `set <key> <val> xx` | key 存在才设置值
| `del <key>` | 删除存储在给定键中的值（可用于所有类型）
| `incr <key>` | key 自增 1，如果 key 不存在 ，则自增后 `get <key>` 等于 1
| `decr <key>` | key 自减 1，如果 key 不存在 ，则自减后 `get <key>` 等于 -1
| `incrby <key> <k>` | key 自增 k，如果 key 不存在 ，则自增后 `get <key>` 等于 k
| `decrby <key> <k>` | key 自减 k，如果 key 不存在 ，则自减后 `get <key>` 等于 -k
| `mset <key1> <val1> <key2> <val2> ...` | 批量设置
| `mget <key1> <key2>` | 批量获取
| `getset <key> <newval>` | 设置新的值同时返回旧的值
| `append <key> <val>` | 将新的 val 追加到旧 val 后，就是字符串追加
| `strlen <key>` | 计算字符串的长度（一个汉字会返回 3）
| `incrbyfloat <key> <float>` | 增加 key 对应的值 3.5
| `getrange <key> <start> <end>` |  获取指定下标的子字符串
| `setrange <key> <index> <val>` | 设置指定下标的子字符串，会覆盖原有的


举个栗子

```
127.0.0.1:6379> set hello world
OK
127.0.0.1:6379> get hello
"world"
127.0.0.1:6379> del hello
(integer) 1
127.0.0.1:6379> get hello
(nil)
127.0.0.1:6379> 
```

## 列表 list

| 命令 | 行为
|:----------
| `rpush <key> <val1> <val2> ...` | 将给定值推入列表的右端
| `linsert <key> before/after <val> <newval>` | 在 list 指定的值前面（后面）插入 newval
| `lrange <key> <start> <end>` | 获取列表在给定范围上的所有值，包括 end
| `lindex <key> <index>` | 获取列表在给定位置上的单个元素
| `lpop <key>` | 从列表的左端弹出一个值，并返回被弹出的值
| `lrem <key> <count> <val> ` | 根据 count 的值，从列表中删除所有和 value 相等的项 <br><br> (1) count>0 ，从左到右，<br>删除最多 count 个和 value 相等的项 <br><br> (2) count<0 ，从右到左，<br>删除最多 Math.abs(count) 个和 value 相等的项 <br><br> (3) count=0 ，删除所有和 value 相等的项
| `ltrim <key> <start> <end>` | 按照索引范围修剪列表，删除索引范围外的元素
| `llen <key>` | 计算列表的长度
| `lset <key> <index> <newval>` | 设置列表指定索引值为 newval
| `blpop <key> <timeout>` | lpop 阻塞版，timeout=0 为永远不阻塞
| `brpop <key> <timeout>` | rpop 阻塞版

``` 
127.0.0.1:6379> rpush names jack
(integer) 1
127.0.0.1:6379> rpush names wang
(integer) 2
127.0.0.1:6379> rpush names jack
(integer) 3
127.0.0.1:6379> lrange names 0 -1 # 表示获取所有的
1) "jack"
2) "wang"
3) "jack"
127.0.0.1:6379> lindex names 1
"wang"
127.0.0.1:6379> lpop names
"jack"
127.0.0.1:6379> lrange names 0 -1
1) "wang"
2) "jack"
```

!> 列表可以存储相同的值

## 集合 set

| 命令 | 行为
|:----------
| `sadd <key> <val>` | 将给定元素添加到集合
| `smembers <key>` | 返回集合包含的所有元素
| `scard <key>` | 计算集合中的元素总数
| `srandmember <key> <count>` | 随机返回 count 个元素
| `spop <key> ` | 随机弹出一个元素
| `sismember <key> <val>` | 检查给定元素是否存在于集合中
| `srem <key> <val>` | 如果给定的元素存在于集合中，那么移除这个元素
| `sdiff <key1> <key2>` | 差集
| `sinter <key1> <key2>` | 交集
| `sunion <key1> <key2>` | 并集

```
127.0.0.1:6379> sadd set-key item
(integer) 1
127.0.0.1:6379> sadd set-key item2
(integer) 1
127.0.0.1:6379> sadd set-key item3
(integer) 1
127.0.0.1:6379> sadd set-key item
(integer) 0
127.0.0.1:6379> smembers set-key
1) "item3"
2) "item2"
3) "item"
127.0.0.1:6379> sismember set-key item4
(integer) 0
127.0.0.1:6379> sismember set-key item
(integer) 1
127.0.0.1:6379> srem set-key item2
(integer) 1
127.0.0.1:6379> srem set-key item4
(integer) 0
127.0.0.1:6379> smembers set-key
1) "item3"
2) "item"
```

## 散列 hash

![](http://os6ycxx7w.bkt.clouddn.com/images/4b99e03b-d969-4aa6-a8cf-5bb7454dc185.png)
> 图片来自慕课网

| 命令 | 行为
|:----------
| `hset <key> <field> <val>` | 在散列中关联给定的键值对
| `hget <key> <field>` | 获取指定散列键的值
| `hgetall <key>` | 获取散列中所有的键值对
| `hvals <key>` | 返回 hash key 对应的所有 field 的 value
| `hkeys <key>` | 返回 hash key 对应的所有 field
| `hdel <key> <field>` | 如果给定键存在于散列中，那么移除这个键
| `hexists <key> <field>` | 判断 hash key 是否有 field
| `hlen <key>` | 计算 hash key field 的数量
|  `hmget <key> <field1> <field2> ...` | 批量获取
|  `hmset <key> <field1> <val1> <field2> <val2> ...` | 批量设置
| `hsetnx <key> <field> <val>` | 已经存在，则失败
| `hincrby <key> <field> <k>` | 对应的 field 自增 k（int）
| `hincrbyfloat <key> <field> <k>` | 对应的 field 自增 k（float）

```
127.0.0.1:6379> hset hash-key sub-key1 value1
(integer) 1
127.0.0.1:6379> hset hash-key sub-key2 value2
(integer) 1
127.0.0.1:6379> hset hash-key sub-key1 value1
(integer) 0
127.0.0.1:6379> hgetall hash-key
1) "sub-key1"
2) "value1"
3) "sub-key2"
4) "value2"
127.0.0.1:6379> hdel hash-key sub-key2
(integer) 1
127.0.0.1:6379> hdel hash-key sub-key2
(integer) 0
127.0.0.1:6379> hget hash-key sub-key1
"value1"
127.0.0.1:6379> hgetall hash-key
1) "sub-key1"
2) "value1"
127.0.0.1:6379> 
```

## 有序集合 zset

有序集合也是存储键值对的，有序集合中的键被称为成员（member），每个成员都是各不相同的。有序集合的值被称为分值（score），分值必须为浮点数。有序集合是 Redis 里面唯一一个既可以根据成员访问元素，又可以根据分值以及分值的排序顺序来访问元素的结构

| 命令 | 行为
|:----------
| `zadd <key> <score> <val> ...` | 将一个带有给定分值的成员添加到有序集合里面 
| `zrange <key> <start_score> <end_score> [withscores]` | 根据元素在有序排列中所处的位置．从有序集合里面获取多个元素 
| `zrangebyscore <key> <min_score> <max_score> [withscores]` | 获取有序集合在给定分值范围内的所有元素
| `zrem <key> <val>` | 如果给定成员存在于有序集合，那么移除这个成员 
| `zremrangebyrank <key> <start> <end>` | 删除指定排名内的升序元素
| `zremrangebyscore <key> <start> <end>` | 删除指定 score 内的升序元素
| `zscore <key> <val>` | 返回元素的 score
| `zincrby <key> <increScore> <val>` | 将元素 val 的 score 加上 increScore
| `zcard <key>` | 返回元素的总数
| `zrank <key> <val>` | 获取 val 的排名，升序
| `zcount <key> <min_score> <max_score>` | 返回有序集合内在指定 score 范围内的个数
| `zrevrank` | 降序
| `zrevrange` | 降序
| `zrevrangebyscore` | 降序
| `zinterstore` | 交集
| `zunionstore` | 并集

```
127.0.0.1:6379> zadd zset-key 728 member1
(integer) 1
127.0.0.1:6379> zadd zset-key 982 member0
(integer) 1
127.0.0.1:6379> zadd zset-key 982 member0
(integer) 0
127.0.0.1:6379> zrange zset-key 0 -1 withscores
1) "member1"
2) "728"
3) "member0"
4) "982"
127.0.0.1:6379> zrangebyscore zset-key 0 800 withscores
1) "member1"
2) "728"
127.0.0.1:6379> zrem zset-key member1
(integer) 1
127.0.0.1:6379> zrem zset-key member1
(integer) 0
127.0.0.1:6379> zrange zset-key 0 -1 withscores
1) "member0"
2) "982"
```