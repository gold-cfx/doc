# 内建函数 
Python 解释器内置了许多函数和类型，它们始终可用。列表如下（按字母排序）。

| -|   -  |  内建函数 |-|-|
| :-------- | :-------| :------ | :------ | :------ |
|[abs()](#absx)	|[delattr()](#delattrobject-name)|	hash()	|memoryview()| set() |  
|[all()](#alliterable)	|[dict()](#dict)|	help()	|min()|	setattr()
|[any()](#anyiterable)	|[dir()](#dirobject)|	hex()|	next()	|slice()|
|[ascii()](#asciiobject)|	[divmod()](#divmoda-b)|	id()|	object()|	sorted()
|[bin()](#binx)	|[enumerate()](#enumerate-iterable-start0)|	input()	|oct()	|staticmethod()
|[bool()](#class-boolx)	|eval()	|int()|	open()	|str()
|breakpoint()|	exec()|	isinstance()	|ord()|	sum()
|[bytearray()](#class-bytearraysource-encoding-errors)|	[filter()](#filterfunction-iterable)|	issubclass()|	pow()|	super()|
|[bytes()](#class-bytessource-encoding-errors)|	[float()](#class-floatx)|	iter()	|print()|	tuple()|
|[callable()](#callableobject)|	[format()](#formatvalue-format_spec)|	len()	|property()|	type()
|[chr()](#chri)|	[frozenset()](#class-frozensetiterable)	|list()|	range()|	vars()|
|[classmethod()](#classmethod)	|[getattr()](#getattrobject-name-default)|	locals()|	repr()	|zip()|
|compile()|	[globals()](globals)|	map()	|reversed()|	`__import__()`|
|[complex()](#class-complexreal-imag)|	[hasattr()](#hasattrobject-name)|	max()	|round()|


## abs(*x*)

返回一个数字的绝对值。参数可以是整数或浮点数。如果参数是一个复数，则返回它的模。

## all(*iterable*)

如果 `iterable` 的所有元素均为 True（或 `iterable` 为空），则返回 `True`。相当于：

``` python
def all(iterable):
    for element in iterable:
        if not element:
            return False
    return True
```

## any(*iterable*)

如果 `iterable` 中有任何一个元素为 true，则返回 `True`。如果 `iterable` 为空，则返回 `False`。相当于：

``` python
def any(iterable):
    for element in iterable:
        if element:
            return True
    return False
```

## ascii(*object*)

类似 `repr()`，返回一个包含对象的可打印表示的字符串，但使用 `\x`，`\u` 或 `\U` 转义符转义由 `repr()` 返回的字符串中的非 ASCII 字符。这会生成一个类似于 Python 2 中 `repr()` 返回的字符串。

``` python
In [1]: s = 'python \n 中文'

In [2]: ascii(s)
Out[2]: "'python \\n \\u4e2d\\u6587'"

In [3]: repr(s)
Out[3]: "'python \\n 中文'"
```

## bin(*x*)

将整数转换为以 “0b” 为前缀的二进制字符串。结果是一个有效的 Python 表达式。如果 `x` 不是Python `int` 对象，则必须定义返回整数的 `__index __()` 方法。一些例子：

``` python
>>> bin(3)
'0b11'
>>> bin(-10)
'-0b1010'
```

可以使用以下任意方式，控制是否需要前缀 “0b”：

``` python
>>> format(14, '#b'), format(14, 'b')
('0b1110', '1110')
>>> f'{14:#b}', f'{14:b}'
('0b1110', '1110')
```
有关更多信息，另请参阅 `format()`。

当 `x` 不是 `int` 类型时

``` python
In [1]: class Test:
   ...:     def __init__(self, n):
   ...:         self.n = n
   ...:
   ...:     def __index__(self):
   ...:         return self.n
   ...:

In [2]: t = Test(10)

In [3]: bin(t)
Out[3]: '0b1010'
```

## *class* bool([*x*])

返回一个布尔值，即 `True` 或 `False` 中的一个。 x 使用标准[真值测试方式](https://docs.python.org/3.7/library/stdtypes.html#truth)进行转换。如果 x 为 false 或省略，则返回 `False`; 否则返回 `True`。 bool 类是 `int` 的子类。它不能进一步子类化。它唯一的实例是 `False` 和 `True`。

## class bytearray([*source*[, *encoding*[, *errors*]]])

返回一个新的字节数组。 bytearray 类是一个在 `0 <= x < 256` 范围内的可变整数序列。

可选的 `source` 参数可以用几种不同的方式初始化数组：
 * 如果它是一个字符串，则还必须给出 encoding（以及可选的 errors）参数; 然后 `bytearray()` 使用 `str.encode()` 将字符串转换为字节。
 * 如果它是一个整数，则将其作为数组的长度，并将用空字节进行初始化。
 * 如果它是符合缓冲区接口的对象，则将使用该对象的只读缓冲区来初始化字节数组。
 * 如果它是一个 iterable，必须是 `0 <= x <256` 范围内的可迭代对象，它们将被用作数组的初始内容。

没有参数，就会创建一个大小为 0 的数组。

``` python
In [11]: bytearray(5)
Out[11]: bytearray(b'\x00\x00\x00\x00\x00')

In [12]: bytearray([23, 32, 4, 67, 9, 96, 123])
Out[12]: bytearray(b'\x17 \x04C\t`{')

In [13]: bytearray()
Out[13]: bytearray(b'')
```

## class bytes([*source*[, *encoding*[, *errors*]]])

返回一个新的 “bytes” 对象，它是一个在 `0 <= x <256` 范围内的不可变整数序列。`bytes` 是 `bytearray` 的不可变版本 - 它具有相同的非变异方法和相同的索引和切片行为。

因此，构造函数参数解释请参考 `bytearray()`。

字节对象也可以使用文字创建。请参阅[字符串和字节文字](https://docs.python.org/3.7/reference/lexical_analysis.html#strings)。


## callable(*object*)

如果 object 参数可调用，则返回 `True`，否则返回 `False`。如果返回 true，调用失败仍然是可能的，但如果是 false，调用 object 将永远不会成功。请注意，类是可调用的（调用一个类返回一个新的实例）; 如果类有一个 `__call __()`方法，则实例可以被调用。

3.2版本中的新功能：此功能在 Python 3.0 中首先被删除，然后在 Python 3.2 中恢复。

``` python
In [19]: a = 1

In [20]: callable(a)
Out[20]: False

In [21]: def func():
    ...:     pass
    ...:

In [22]: callable(func)
Out[22]: True

In [23]: class A:
    ...:     pass
    ...:

In [24]: a = A()

In [25]: callable(a)
Out[25]: False

In [26]: class A:
    ...:     def __call__(self, *args, **kwargs):
    ...:         pass
    ...:

In [27]: a = A()

In [28]: callable(a)
Out[28]: True
```

## chr(*i*)

返回表示 Unicode 代码点为整数 i 的字符的字符串。例如，`chr(97)` 返回字符串 `'a'`，而 `chr(8364)` 返回字符串 `'€'`。这是 `ord()` 的逆过程。

参数的有效范围是从 0 到 1,114,111（基于 16 的 0x10FFFF）。如果超出这个范围，将会抛出 ValueError。

## @classmethod

将方法转换为类方法。

类方法将类作为第一个参数接收（隐式的），就像实例方法接收实例一样。为了声明一个类方法，习惯用法如下：
``` python
class C:
    @classmethod
    def f(cls, arg1, arg2, ...): ...
```

!> 注意：类方法和静态方法不是一个概念


## class complex([*real*[, *imag*]])

返回值为 real + imag*1j 的复数或者将字符串或数字转换为复数。如果第一个参数是一个字符串，它将被解释为一个复数，并且该函数必须在没有第二个参数的情况下被调用。第二个参数不能是一个字符串。每个参数可以是任何数字类型（包括复数）。如果省略了 imag，它将默认为零，并且构造函数用作像 int 和 float 这样的数字转换。如果两个参数均被省略，则返回 0j。

!> 从字符串转换时，该字符串不得在 `+` 或 `-` 运算符周围包含空格。例如，`complex('1+2j')` 很好，但 `complex('1 + 2j')` 会引发 `ValueError`。


## delattr(object, name)
参数是一个对象和一个字符串。该字符串必须是对象属性之一的名称。该函数删除指定的属性（只要该对象允许）。例如， `delattr(x, 'foobar')` 等价于 `del x.foobar`。

## dict

class dict(`**kwarg`)
class dict(`mapping`, `**kwarg`)
class dict(`iterable`, `**kwarg`)

创建一个新的字典

``` python
In [38]: dict(name='jack',age=18)
Out[38]: {'name': 'jack', 'age': 18}

In [39]: dict({'name': 'jack'}, age=18)
Out[39]: {'name': 'jack', 'age': 18}

In [40]: dict([('name', 'jack'),('age', 18)])
Out[40]: {'name': 'jack', 'age': 18}
```

## dir([*object*])
尝试返回 object 的有效属性列表。如果没有参数，则返回当前本地作用域中的名称列表。

如果对象具有名为 `__dir__()` 的方法，则将调用此方法，并且必须返回属性列表。这允许实现自定义 `__getattr__()`或 `__getattribute__()` 函数的对象自定义 `dir()` 报告其属性。

默认的 `dir()` 机制对不同类型的对象有不同的表现，因为它试图产生最相关的信息，而不是完整的信息：
* 如果对象是模块对象，则列表包含模块属性的名称。
* 如果对象是一个类型或类对象，则该列表包含其属性的名称，并递归地显示其基础的属性。
* 否则，该列表包含对象的属性名称，其类属性的名称以及其类的基类的属性的递归。

结果列表按字母顺序排序。例如：
``` python
>>> import struct
>>> dir()   # show the names in the module namespace  
['__builtins__', '__name__', 'struct']
>>> dir(struct)   # show the names in the struct module 
['Struct', '__all__', '__builtins__', '__cached__', '__doc__', '__file__',
 '__initializing__', '__loader__', '__name__', '__package__',
 '_clearcache', 'calcsize', 'error', 'pack', 'pack_into',
 'unpack', 'unpack_from']
>>> class Shape:
...     def __dir__(self):
...         return ['area', 'perimeter', 'location']
>>> s = Shape()
>>> dir(s)
['area', 'location', 'perimeter']
```

## divmod(*a*, *b*)

以两个（非复数）数字作为参数，并在使用整数除法时返回由它们的商和余数组成的一对数字。使用混合操作数类型时，适用二元算术运算符的规则。对于整数，结果与 `(a // b, a % b)` 相同。对于浮点数，结果是 `(q, a % b)`，其中 q 通常是 `math.floor(a / b) `，但可能小于 1。在任何情况下， `q * b + a % b` 都非常接近 a，如果 `a % b` 不为零，则它具有与 b 相同的符号，并且 `0 <= abs(a % b) < abs(b)`。

``` python
In [53]: divmod(10, 3)
Out[53]: (3, 1)

In [54]: divmod(10.1, 3)
Out[54]: (3.0, 1.0999999999999996)
```

## enumerate( *iterable*, *start=0*)
返回一个枚举对象。 iterable 必须是一个序列，一个迭代器或其他支持迭代的对象。由 `enumerate()` 返回的迭代器的 `__next__()` 方法返回一个元组，该元组包含一个计数（从 start 开始，默认值为 0）以及遍历迭代获得的值。

``` python
>>> seasons = ['Spring', 'Summer', 'Fall', 'Winter']
>>> list(enumerate(seasons))
[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
>>> list(enumerate(seasons, start=1))
[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]
```

相当于：

``` python
def enumerate(sequence, start=0):
    n = start
    for elem in sequence:
        yield n, elem
        n += 1
```


## filter(*function, iterable*)
用那些 function 返回 true 的 iterable 元素构造一个迭代器。iterable 可以是序列，支持迭代的容器或迭代器。如果 function 为 `None`，则假定标识函数为 false，即为 false 的所有元素都被删除。

!> 请注意，如果 function 不是 `None` ，`filter(function, iterable)` 等价于生成器表达式 `(item for item in iterable if function(item))` 。如果 function 是 `None`，等价于生成器表达式 ` (item for item in iterable if item)` 。

``` python
In [8]: list(filter(None, [False, True, 0, 'test']))
Out[8]: [True, 'test']
```

## *class* float([*x*])
返回一个由数字或字符串 x 构造的浮点数。

在删除前后空白字符后，输入必须符合以下语法：
``` python
sign           ::=  "+" | "-"
infinity       ::=  "Infinity" | "inf"
nan            ::=  "nan"
numeric_value  ::=  floatnumber | infinity | nan
numeric_string ::=  [sign] numeric_value
```

对于一般的 Python 对象 x，`float(x)` 委托给 `x .__float__()`。

如果没有给出参数，则返回 0.0。

例子：

``` python
>>> float('+1.23')
1.23
>>> float('   -12345\n')
-12345.0
>>> float('1e-003')
0.001
>>> float('+1E6')
1000000.0
>>> float('-Infinity')
-inf
```

## format(*value*[, *format_spec*])
将值转换为 “格式化” 表示，由 format_spec 控制。 format_spec 的解释将取决于 value 参数的类型，不过，大多数内置类型都使用标准格式化语法：[格式化规范迷你语言](https://docs.python.org/3.7/library/string.html#formatspec)。

默认 format_spec 是一个空字符串，通常与调用 str(value) 的效果相同。

对 `format(value, format_spec)` 的调用被转换为 `type(value).__format__(value, format_spec)`，它在搜索 value 的 `__format__()` 方法时绕过实例字典。如果方法搜索到达 object 并且 format_spec 非空，或者 format_spec 或返回值不是字符串，则会引发 TypeError 异常。

在 version 3.4 中：如果 format_spec 不是空字符串，则 `object().__format__(format_spec)` 会引发 `TypeError`。

## class frozenset([*iterable*])
返回一个新的 frozenset 对象，可选地使用来自 iterable 的元素。 `frozenset` 是一个内置的类。

`frozenset` 是不可变的，存在哈希值，它可以作为字典的 key，也可以作为其它集合的元素。一旦创建便不能更改，没有 add，remove 方法。

## getattr(*object*, *name*[, *default*])

返回 object 的指定属性的值。name 必须是字符串。如果字符串是 object 属性之一的名称，则结果是该属性的值。例如，`getattr(x, 'foobar')` 等同于 `x.foobar`。如果指定的属性不存在，则返回默认值（如果提供），否则引发 `AttributeError`。


## globals()

返回表示当前全局符号表的字典。它总是当前模块的字典（在函数或方法内部，它是定义它的模块，而不是从中调用它的模块）。

## hasattr(*object*, *name*)

参数是一个对象和一个字符串。如果字符串是 object 属性之一的名称，则结果为 `True`，否则为 `False`。（这是通过调用 `getattr(object, name)` 并查看它是否引发 `AttributeError` 实现的。）

## hash(object)
## help([object])
## hex(x)
## id(object)
## input([prompt])
## int
class int(x=0)
class int(x, base=10)
## isinstance(object, classinfo)
## issubclass(class, classinfo)
## iter(object[, sentinel])
## len(s)
## class list([iterable])
## locals()
## map(function, iterable, ...)
## max
max(iterable, *[, key, default])
max(arg1, arg2, *args[, key])